<br> 
<center><img src="http://i.imgur.com/sSaOozN.png" width="500"></center>


## Course: VISUAL ANALYTICS FOR POLICY AND MANAGEMENT

### Prof. José Manuel Magallanes, PhD 
* Visiting Professor of Computational Policy at Evans School of Public Policy and Governance, and eScience Institute Senior Data Science Fellow, University of Washington.
* Professor of Government and Political Methodology, Pontificia Universidad Católica del Perú. 


_____

<a id='TOC'></a>

# Tabular data - Bivariate relationships I: Categorical-Categorical


We analyze two variables to find out if there might be some kind of association between them. Even though that may be difficult to clearly identify, bivariate analysis still helps reveal _signs_ of association that may serve at least to raise concern.


Let me use the [data about crime](https://data.seattle.gov/Public-Safety/Crime-Data/4fs7-3vj5) from the Seattle Open Data portal (I have formatted  this  file previously).

```{r collect, eval=TRUE}
# clear memory
rm(list = ls())
# collecting the data
link="https://github.com/EvansDataScience/data/raw/master/crime.RData"
load(file = url(link)) #loaded as 'crime'
```

Let's see what kind of data we have in **crime** data table:

```{r str, eval=TRUE}
# categorical? numerical?
str(crime,width = 50,strict.width='cut')
```

_____


# Categorical-Categorical relationships

While we use _frequency tables_ in the univariate case, for the bivariate case (cat-cat) we prepare _**contingency tables**_. Let's select a couple of categorical variables:

* Precinct (where crimes occur)
* Occurred.DayTime (when crimes occur)

This contingency table shows counts for each combination of levels:
```{r, eval=TRUE}
(PrecinctDaytime=table(crime$Precinct,crime$Occurred.DayTime))
```

When a table tries to hypothesize a relationship, you should have the _independent_ variable in the columns, and the _dependent_ one in the rows. 
Interpretation is difficult when you have counts so it is better to have percents. Percents should be computed by column to see how the levels of the dependent variable varies by each level of the independent one (reading along rows):

```{r, eval=TRUE}
# computing column percent from contingency table
library(magrittr) # for %>%
(PrecDayti_mgCol=prop.table(PrecinctDaytime,
                            margin = 2) #2 means by column
                             %>%round(.,3))
```


The previous table shows you how the crimes that occur in a precinct _are affected_ by the time they happen. So you need a plot that allows to highlight those differences accross time.

As before, we need to turn this table into a data frame:

```{r, eval=TRUE}
#making a data frame from contingency table
(PrecDaytiDF=as.data.frame(PrecinctDaytime))
```
We also have the table with marginal percents by column:

```{r}
as.data.frame(PrecDayti_mgCol)
```
We should simply add the last column to the data frame of counts.

```{r}
PrecDaytiDF$share=as.data.frame(PrecDayti_mgCol)[,3]
PrecDaytiDF
```

We can change the names of the previous data frame:
```{r}
names(PrecDaytiDF)[1:3]=c("precinct","daytime","counts")

#then
PrecDaytiDF


```

We will use _ggplot_ to represent the _contingency table_:

```{r base, eval=TRUE}
library(ggplot2)
base1=ggplot(data=PrecDaytiDF, 
             aes(x=daytime,
                 y=share,
                 fill=precinct)) # fill brings a legend
```

Then, you play with some positions for the bar. First, the **dodge** style:

```{r, eval=TRUE}
barDodge= base1 +  geom_bar(stat="identity",
                            position ='dodge') 
barDodge 
```

The second is the **stack** style:

```{r, eval=TRUE}
barStacked = base1 + geom_bar(stat = "identity",
                              position = 'stack')#default
barStacked 
```

The stacked version will help more than the dodged one as it reveals better the values in the contingency table:
```{r}
PrecDayti_mgCol
```


So, we continue with adding some elements to this one:

```{r, eval=TRUE}
library(scales)
#annotating
barStackedAnn= barStacked + geom_text(size = 5,# check below:
                             position = position_stack(vjust = 0.5),# center
                             aes(label=percent(share,accuracy = 0.1)))# percent format

barStackedAnn = barStackedAnn + scale_y_continuous(labels = percent)

barStackedAnn
```

Since the precinct is nominal, and you see some marked differences along the percents, you can reorder the precinct blocks with **reorder()**:

```{r, eval=TRUE}

base1=ggplot(data=PrecDaytiDF, 
             aes(x=daytime, y=share,
                 fill=reorder(precinct,share))) ## reordering

barStacked = base1 + geom_bar(stat = "identity",
                              position = 'stack')
barStacked= barStacked + geom_text(size = 5,
                             position = position_stack(vjust = 0.5),
                             aes(label=percent(share,accuracy = 0.1)))

barStacked = barStacked + scale_y_continuous(labels = percent)

barStacked


```

Let me show you a more complex situation:

```{r table, eval=TRUE}
# contingency table with many levels:

(CrimeDay=table(crime$crimecat,crime$Occurred.DayTime))
```

This contingency table has one categorical variables with several levels, let's prepare a data frame as before:

```{r, eval=TRUE}
#making a data frame from contingency table
CrimeDayDF=as.data.frame(CrimeDay)
#marginal
CrimeDay_mgCol=prop.table(CrimeDay,margin = 2)
#renaming:
names(CrimeDayDF)=c("crime","daytime","counts")
#adding marginal
CrimeDayDF$share=as.data.frame(CrimeDay_mgCol)[,3]
# result for ggplot:
head(CrimeDayDF,20)
```


Sometimes, a simple contingency table does not need to be plotted in order to reveal salient relationships; but in this case a visual may be needed.

As before, let's request a _stacked_ barplot:

```{r BADplot,eval=TRUE}
# bad idea
base2=ggplot(data=CrimeDayDF,
             aes(x=daytime,y=share,fill=crime))

base2=base2 + geom_bar(stat = "identity", position = 'fill') + 
        geom_text(size = 3, 
                  position = position_stack(vjust = 0.5),
                  aes(label=percent(share,accuracy = 0.1)))

barStacked2 = base2 + scale_y_continuous(labels = percent)

barStacked2
```

This plot will need a lot of work, so using it may not be a good strategy.  

A first option you be to use a _barplot_ with **facets** with bars _dodged_. Let'a make the first attempt.

```{r facet, eval=TRUE}
# base with only X and Y in 'aes()'
baseBar = ggplot(CrimeDayDF, aes(x = crime, y = share ) ) 

#the bars
barPlot  = baseBar + geom_bar( stat = "identity" ) 

barPlot
```
Now see the facets:

```{r}

# bar per day time with 'facet'
barsFt = barPlot + facet_grid(~ daytime) 

barsFt
```

This does not look like the crosstable yet; let's solve that:

```{r}
barsFt + coord_flip()
```


The type of crime is not ordinal, then we could **reorder** the bars:

```{r orderFacet, eval=TRUE}
# new base
baseRE  = ggplot(CrimeDayDF, 
                 aes(x = reorder(crime, share), #here
                     y = share ) ) + theme_minimal()

barPlotRE = baseRE + geom_bar( stat = "identity" ) 
barFtRE = barPlotRE + facet_grid( ~ daytime) 
barFtRE= barFtRE + coord_flip() 


barFtRE
```

Let's work on the crime _labels_
```{r, eval=TRUE}

barFtRE=barFtRE + theme(axis.text.y = element_text(size=7,angle = 20)) 
barFtRE
```
Would you annotate the bars:
```{r}
barREann= barFtRE+ geom_text(aes(label=round(share,2)),
                             nudge_y = 0.1)
barREann
```

Let's annotate conditionally instead:

```{r, eval=TRUE}

barCond=barFtRE + geom_text(aes(label=ifelse(share>0.1,# condition to annotate
                                      round(share,2),"")),
                     nudge_y = 0.1)
barCond
```
What about percents instead:

```{r, eval=TRUE}

barFtRE + geom_text(aes(label=ifelse(share>0.1,
                                      percent(share,accuracy = 1),# %
                                     "")),
                     nudge_y = 0.1,size=3) + 
           scale_y_continuous(labels = percent_format(accuracy = 1,suffix="")) #%

```
